//
// Created by Alan de Freitas on 20/11/2017.
//

#ifndef WPP_QUERY_BUILDER_HPP
#define WPP_QUERY_BUILDER_HPP
namespace wpp {
    namespace db {
        query_builder::query_builder(db::connection& _connection,
             std::shared_ptr<db::query_grammar> __grammar = nullptr,
             std::shared_ptr<db::processor> __processor = nullptr):
                _connection(_connection),
                _grammar(__grammar ? __grammar : _connection->get_query_grammar()),
                _processor(__processor ? __processor : _connection->get_post_processor())
        {
        }

        query_builder::query_builder(db::connection& _connection,
             db::query_grammar &__grammar,
             db::processor &__processor):
                _connection(_connection),
                _grammar(new query_grammar(__grammar)),
                _processor(new processor(__processor))
        {
        }

        template<typename string_or_self>
        self_t & query_builder::select_sub(string_or_self _query, string _as) {
            string query_str;
            // Here, we will parse this query into an SQL string and an vector<string> of bindings
            // so we can add it to the query query_builder using the select_raw method so the
            // query is included in the real SQL generated by this query_builder instance.
            std::tie(query_str, _bindings) = this->parse_sub_select(_query);

            return this->select_raw("(" + query_str + ") as " + this->_grammar->wrap(_as), _bindings);
        }

        self_t & query_builder::join(string _table,
                     string _first,
                     string _operator = "",
                     string _second = "",
                     string _type = "inner",
                     bool _where = false) {
            join_clause _join(*this, _type, _table);

            string _method = _where ? "where" : "on";

            this->_joins.push_back(_join->_method(_first, _operator, _second));

            this->add_binding(_join->get_bindings(), "join");

            return *this;
        }

        self_t & query_builder::join(string _table,
                     function<string(join_clause&)> _first,
                     string _operator = "",
                     string _second = "",
                     string _type = "inner",
                     bool _where = false) {
            join_clause _join(*this, _type, _table);

            // If the first "column" of the join is really a Closure instance the developer
            // is trying to build a join with a complex "on" clause containing more than
            // one condition, so we"ll add the join and call a Closure with the query.
            _first(_join);

            this->_joins.push_back(_join);

            this->add_binding(_join->get_bindings(), "join");

            return *this;
        }

        self_t & query_builder::cross_join(string _table, string _first = "", string _operator = "", string _second = "") {
            if (!_first.empty()) {
                return this->join(_table, _first, _operator, _second, "cross");
            }

            this->_joins.emplace_back(join_clause(*this, "cross", _table));

            return *this;
        }

        bool query_builder::invalid_operator(string _operator) {
            return !utils::in_array(utils::strtolower(_operator), this->_operators) &&
                   !utils::in_array(utils::strtolower(_operator), this->_grammar->get_operators());
        }

        void query_builder::merge_wheres(vector<where_properties> _wheres, vector<string> _bindings) {
            this->_wheres.insert(this->_wheres.end(),_wheres.begin(), _wheres.end());
            this->_bindings["where"].insert(this->_bindings["where"].end(), _bindings.begin(), _bindings.end());
        }

        self_t & query_builder::where(string column, string _operator = "") {
            string value = _operator;
            _operator = "=";
            string boolean = "and";
            // If the value is "null", we will just assume the developer wants to add a
            // where null clause to the query. So, we will allow a short-cut here to
            // that method for convenience so the developer doesn"t have to check.
            if (value.empty()) {
                return this->where_null(column, boolean, _operator != "=");
            }

            string type = "Basic";

            where_properties w;
            w.type = type;
            w.column = column;
            w.operator_ = _operator;
            w.value = value;
            w.boolean = boolean;

            this->_wheres.push_back(w);

            this->add_binding(value, "where");

            return *this;

        }

        self_t & query_builder::where(string column, string _operator, string value, string boolean = "and") {
            // Here we will make some assumptions about the operator. If only 2 values are
            // passed to the method, we will assume that the operator is an equals sign
            // and keep going. Otherwise, we"ll require the operator to be passed in.
            this->prepare_value_and_operator(value, _operator, false);

            // If the given operator is not found in the list of valid operators we will
            // assume that the developer is just short-cutting the "=" operators and
            // we will set the operators to "=" and set the values appropriately.
            if (this->invalid_operator(_operator)) {
                value = _operator;
                _operator = "=";
            }

            if (value.empty()) {
                return this->where_null(column, boolean, _operator != "=");
            }

            string type = "Basic";

            where_properties w;
            w.type = type;
            w.column = column;
            w.operator_ = _operator;
            w.value = value;
            w.boolean = boolean;

            this->_wheres.push_back(w);

            this->add_binding(value, "where");

            return *this;


        }

        self_t &
        query_builder::where_column(string _first, string _operator = "", string _second = "", string _boolean = "and") {
            // If the given operator is not found in the list of valid operators we will
            // assume that the developer is just short-cutting the "=" operators and
            // we will set the operators to "=" and set the values appropriately.
            if (this->invalid_operator(_operator)) {
                _second = _operator;
                _operator = "=";
            }

            // Finally, we will add this where clause into this vector<string> of clauses that we
            // are building for the query. All of them will be compiled via a grammar
            // once the query is about to be executed and run against the database.
            string _type = "Column";

            where_properties w;
            w.type = type;
            w.first = _first;
            w.operator_ = _operator;
            w.second = _second;
            w.boolean = boolean;

            this->_wheres.push_back(w);

            return *this;
        }


        self_t & query_builder::where_raw(string _sql, vector<string> _bindings = {}, string _boolean = "and") {
            where_properties w;
            w.type = "raw";
            w.sql = _sql;
            w.boolean = _boolean;
            this->_wheres.push_back(w);

            this->add_binding(_bindings, "where");
            return *this;
        }

        self_t &
        query_builder::where_in(string _column, vector<string> _values, string _boolean = "and", bool _not = false) {
            string _type = _not ? "NotIn" : "In";

            where_properties w;
            w.type = _type;
            w.column = _column;
            w.values = _values;
            w.boolean = _boolean;
            this->_wheres.push_back(w);

            // Finally we"ll add a binding for each values unless that value is an expression
            // in which case we will just skip over it since it will be the query as a raw
            // string and not as a parameterized place-holder to be replaced by the PDO.
            for (string &_value: _values) {
                this->add_binding(_value, "where");
            }

            return *this;
        }

        template<typename Closure>
        self_t & query_builder::where_in_sub(string _column, Closure _callback, string _boolean, bool _not) {
            string _type = _not ? "NotInSub" : "InSub";

            // To create the exists sub-select, we will actually create a query and call the
            // provided callback with the query so the developer may set any of the query
            // conditions they want for the in clause, then we'll put it in this vector<string>.
            query_builder _query = this->new_query();
            _callback(_query);

            where_properties w;
            w.type = _type;
            w.column = _column;
            w.query = _query;
            w.boolean = _boolean;
            this->_wheres.push_back(w);

            this->add_binding(_query->get_bindings(), "where");

            return *this;
        }

        self_t & query_builder::where_in_existing_query(string _column, query_builder _query, string _boolean, bool _not) {
            string _type = _not ? "NotInSub" : "InSub";

            where_properties w;
            w.type = _type;
            w.column = _column;
            w.query = _query;
            w.boolean = _boolean;
            this->_wheres.push_back(w);

            this->add_binding(_query->get_bindings(), "where");

            return *this;
        }

        self_t & query_builder::where_null(string _column, string _boolean = "and", bool _not = false) {
            _type = _not ? "NotNull" : "Null";

            where_properties w;
            w.type = _type;
            w.column = _column;
            w.boolean = _boolean;
            this->_wheres.push_back(w);

            return *this;
        }

        self_t &
        query_builder::where_between(string _column, vector<string> _values, string _boolean = "and", bool _not = false) {
            string _type = "between";

            where_properties w;
            w.type = _type;
            w.column = _column;
            w.boolean = _boolean;
            w.not_ = _not;
            this->_wheres.push_back(w);


            this->add_binding(_values, "where");

            return *this;
        }

        self_t & query_builder::add_date_based_where(string _type,
                                     string _column,
                                     string _operator,
                                     int _value,
                                     string _boolean = "and") {
            where_properties w;
            w.column = _column;
            w.type = _type;
            w.boolean = _boolean;
            w.operator_ = _operator;
            w.value = to_string(_value);

            this->_wheres.push_back(w);

            this->add_binding(_value, "where");
            return *this;
        }

        self_t &query_builder::add_nested_where_query(query_builder _query, string _boolean = "and") {
            if (!_query._wheres.empty()) {
                string _type = "Nested";

                where_properties w;
                w.type = _type;
                w.query = _query;
                w.boolean = _boolean;
                this->_wheres.push_back(w);

                this->add_binding(_query->get_bindings(), "where");
            }
            return *this;
        }

        template<typename Closure>
        self_t &query_builder::where_sub(string _column, string _operator, Closure _callback, string _boolean) {
            string _type = "Sub";

            // Once we have the query instance we can simply execute it so it can add all
            // of the sub-select"s conditions to itself, and then we can cache it off
            // in the vector<string> of where clauses for the "main" parent query instance.
            query_builder _query = this->new_query();
            _callback(_query);

            where_properties w;
            w.type = _type;
            w.column = _column;
            w.operator_ = _operator;
            w.query = _query;
            w.boolean = _boolean;
            this->_wheres.push_back(w);


            this->add_binding(_query->get_bindings(), "where");

            return *this;
        }

        self_t &query_builder::add_where_exists_query(query_builder _query, string _boolean = "and", bool _not = false) {
            string _type = _not ? "NotExists" : "Exists";

            where_properties w;
            w.type = _type;
            w.query = _query;
            w.boolean = _boolean;
            this->_wheres.push_back(w);


            this->add_binding(_query->get_bindings(), "where");

            return *this;
        }

        self_t & query_builder::having(string _column, string _operator, string _value, string _boolean = "and") {
            string _type = "Basic";

            // Here we will make some assumptions about the operator. If only 2 values are
            // passed to the method, we will assume that the operator is an equals sign
            // and keep going. Otherwise, we"ll require the operator to be passed in.
            if (this->invalid_operator(_operator)){
                _operator = "=";
            }

            having_properties h;
            h.type = _type;
            h.column = _column;
            h.operator_ = _operator;
            h.value = _value;
            h.boolean = _boolean;

            this->_havings.push_back(h);

            this->add_binding(_value, "having");

            return *this;
        }

        self_t & query_builder::having_raw(string _sql, vector<string> _bindings = {}, string _boolean = "and") {
            _type = "Raw";

            having_properties h;
            h.type = _type;
            h.sql = _sql;
            h.boolean = _boolean;

            this->_havings.push_back(h);


            this->_havings.push_back({{"type",    _type},
                                      {"sql",     sql},
                                      {"boolean", boolean}});

            this->add_binding(_bindings, "having");

            return *this;
        }

        self_t & query_buidler::order_by(string _column, string _direction = "asc") {
            order_properties o;
            order_properties.column = _column;
            order_properties.direction = (utils::str_to_lower(_direction) == "asc" ? "asc" : "desc");
            if (this->_unions) {
                this->_union_orders.push_back(o);
            } else {
                this->_orders.push_back(o);
            }

            return *this;
        }

        self_t & query_builder::in_random_order(string _seed = "") {
            return this->order_by_raw(this->_grammar->compile_random(_seed));
        }

        self_t & query_builder::order_by_raw(string _sql, vector<string> _bindings = {}) {
            order_properties o;
            order_properties.type = "Raw";
            order_properties.sql = _sql;

            if (this->_unions) {
                this->_union_orders.push_back(o);
            } else {
                this->_orders.push_back(o);
            }

            this->add_binding(_bindings, "order");

            return *this;
        }

        vector<order_properties> query_builder::remove_existing_orders_for(string _column) {
            vector<order_properties> collection = this->_orders;
            vector<order_properties>::iterator iter = std::remove_if(collection.begin(), collection.end(),
                                                                     [&_column](order_properties &x) {
                                                                         return x.columns == _column;
                                                                     });
            collection.erase(iter, collection.end());
            return collection;
        }

        self_t &query_builder::union_statement(query_builder _query, bool _all = false) {
            union_properties u;
            u.query = _query;
            u.all = _all;
            this->_unions.push_back(u);
            this->add_binding(_query.get_bindings(), "union");
            return *this;
        }

        template<typename Closure>
        self_t &query_builder::union_statement(Closure _closure_query, bool _all = false) {
            _query = this->new_query();
            _closure_query(_query);

            union_properties u;
            u.query = _query;
            u.all = _all;

            this->_unions.push_back(u);

            this->add_binding(_query.get_bindings(), "union");
            return *this;
        }

        string query_builder::to_sql() {
            return this->_grammar->compile_select(*this);
        }

        vector<string> query_builder::run_select() {
            return this->_connection->select(this->to_sql(), this->get_bindings(), !this->_use_write_pdo);
        }

        generator query_builder::cursor() {
            if (this->_columns.empty()) {
                this->_columns = {"*"};
            }

            return this->_connection->cursor(this->to_sql(), this->get_bindings(), !this->_use_write_pdo);
        }

        bool query_builder::exists() {
            vector<string> results = this->_connection->select(
                    this->_grammar->compile_exists(this), this->get_bindings(), !this->_use_write_pdo
            );

            // If the results has rows, we will get the row and see if the exists column is a
            // boolean true. If there is no results for this query we will return false as
            // there are no rows for this query at all and we can return that info here.
            if (!results.empty()) {
                results = {results[0]};

                return results.count("exists");
            }

            return false;
        }

        // Insert a new record into the database.
        bool query_builder::insert(map<string, string> values) {
            // Since every insert gets treated like a batch insert, we will make sure the
            // bindings are structured in a way that is convenient when building these
            // inserts statements by verifying these elements are actually an array.
            if (values.empty()) {
                return true;
            }

            // Here, we will sort the insert keys for every record so that each insert is
            // in the same order for the record. We need to make sure this is the case
            // so there are not any errors or problems when inserting these records.
            //else {
            //    for (string& value: values) {
            //ksort(value);
            //values[key] = value;
            //}
            //}

            // Finally, we will run this query against the database connection and return
            // the results. We will need to also flatten these bindings before running
            // the query so they are all in one huge, flattened array for execution.
            return this->_connection->insert(
                    this->_grammar->compile_insert(this, values),
                    //this->clean_bindings(Arr::flatten(values, 1))
                    this->clean_bindings(values, 1)
            );
        }

        int query_builder::insert_get_id(vector<string> values, string sequence = "") {
            std::string sql = this->_grammar->compile_insert_get_id(this, values, sequence);

            values = this->clean_bindings(values);

            return this->_processor->process_insert_get_id(this, sql, values, sequence);
        }

        int query_builder::update(vector<pair<string,string>> values) {
            std::string sql = this->_grammar->compile_update(this, values);

            return this->_connection->update(sql, this->clean_bindings(
                    this->_grammar->prepare_bindings_for_update(this->_bindings, values)
            ));
        }

        int query_builder::increment(string column, int amount = 1, vector<string> extra = {}) {
            query_grammar wrapped = this->_grammar->wrap(column);
            map<string, string> columns;
            columns[column] = this->raw("wrapped + amount");
            columns.insert(extra.begin(), extra.end());
            return this->update(columns);
        }

        int query_builder::decrement(string column, int amount = 1, vector<string> extra = {}) {
            query_grammar wrapped = this->_grammar->wrap(column);
            map<string, string> columns;
            columns[column] = this->raw("wrapped - amount");
            columns.insert(extra.begin(), extra.end());
            return this->update(columns);
        }

        template<typename ID_TYPE>
        int query_builder::delete_entry(ID_TYPE id = -1) {
            // If an ID is passed to the method, we will set the where clause to check the
            // ID to let developers to simply and quickly remove a single row from this
            // database without manually specifying the "where" clauses on the query.
            if (id != -1) {
                this->where(this->_from + ".id", "=", id);
            }

            return this->_connection->delete_entry(this->_grammar->compile_delete(this), this->get_bindings());
        }

        void query_builder::truncate() {
            for (auto &item: this->_grammar->compile_truncate(this)) {
                auto sql = item.first;
                auto bindings = item.second;
                this->_connection->statement(sql, bindings);
            }
        }

        template<typename MIXED>
        string query_builder::raw(MIXED value) {
            return this->_connection->raw(value);
        }

        connection query_builder::get_connection() {
            return this->_connection;
        }

        query_grammar query_builder::get_grammar() {
            return this->_grammar;
        }







    }
}
#endif //WPP_QUERY_BUILDER_HPP
